TITLE: Frequently Asked Questions about RISC-V Software
--------------------------------

# Frequently Asked Questions about RISC-V Software

As the maintainer of various RISC-V related software projects, I've found that
I keep answering the same questions about RISC-V -- frequently from the same
people!  As such, I think it's best to maintain a FAQ list so people don't have
to keep asking the same question over and over again via email.

This FAQ focuses on answering common questions about RISC-V software.  Each
subject contains a short list that contains every question along with a
one-sentence answer, along with a link to a longer-form answer.  If you're new
to RISC-V, it will probably save you time in the long run to read all the short
answers, as you'll probably end up needing to figure most of them out at some
point anyway.  The longer answers tend to be quite verbose as they describe not
only the answer but why we arrived at that particular solution, and as such are
meant to be more fun than useful.

If you think a question should be on this list, then feel free to either
[email](http://www.google.com/recaptcha/mailhide/d?k=01fm-8WTM-kTwRkZd8rLZxmQ==&c=Bu87McGCMC3MvPApw0RqbH1gzipCRUUpLnzplgltk-I=)
me or submit a [pull
request](https://github.com/palmer-dabbelt/website/compare) against the source
of this website.

## Short-Form Answers

### Contributing to RISC-V Projects

[How do I file a bug?](#how-do-i-file-a-bug-): Look up the
[maintainer](riscv-maintainers.html) and file it however they suggest.

[How do I submit a patch?](#how-do-i-submit-a-patch-): Look up the
[maintainer](riscv-maintainers.html) and submit it however they suggest.

[Is there a list of issues?](#is-there-a-list-of-issues-): There's a list per
project on our [github](https://github.com/riscv), see below for a bit more
info.

### The RISC-V Toolchain (GCC, binutils, glibc, and newlib)

[What is the difference between the -mabi and -march
options?](#what-is-the-difference-between-the--mabi-and--march-options-):
-march selects the architecture (a.k.a. ISA), -mabi selects the ABI, and -mtune
selects the microarchitecture.

[Where is the 32-bit toolchain?](#where-is-the-32-bit-toolchain-): Toolchains
prefixed by riscv32 and riscv64 support all RISC-V ISAs, just pass -march=ISA
and -mabi=ABI.

[What is a code model?](#what-is-a-code-model-): The code model determines
which relocations are generated by GCC when generating assembly.  The code
model can be specified by the -mcmodel option to GCC.

[What does -mcmodel=medlow mean?](#what-does--mcmodel-medlow-mean-): This
selects the medium-low code model, which means program and its statically
defined symbols must lie within a single 2 GiB address range and must lie
between absolute addresses -2 GiB and +2 GiB.

[What does -mcmodel=medany mean?](#what-does--mcmodel-medany-mean-): This
selects the medium-any code model, which means program and its statically
defined symbols must lie within any single 2 GiB address range.

[What is linker relaxation?](#what-is-linker-relaxation-): Linker relaxation is
a mechanism for optimizing programs at link time that deletes unused
relocations (and their corresponding instructions) that the RISC-V toolchain
makes heavy use of in order to avoid extra [code
models](#what-is-a-code-model-).

## Long-Form Answers

### Contributing to RISC-V Projects

#### How do I file a bug?

Before contributing to a project, you should at least read the relevant
section's short-form FAQ entries as it's possibly the problem you're trying to
fix is one we've already encountered.  If you see your problem there, you
should read the long-form FAQ entry as it's possible we've already though of
your solution and there's a reason it's not feasible.

When you're sure what you've found is a valid bug, the RISC-V port is upstream,
and you're comfortable with whatever bug tracking system upstream uses; then
feel free to file the bug upstream.  Otherwise, check the [maintainers
list](riscv-maintainers.html) for the location we track bugs for out-of-tree
ports or a secondary bug tracker that may be easier to use.

#### How do I submit a patch?

Just like every project tracks bugs in a different manner, every project has
their own special way of managing patches.  In general, if you're familiar with
the project then we are fine accepting code contributions however upstream
handles them -- though if you're familiar with the project, you're probably
either not here or the RISC-V port isn't upstream yet so there isn't a
maintainer.

If you're looking for specific help as to how to submit a patch to the RISC-V
maintainers of an in-tree port, an out-of-tree port, or some RISC-V-specific
software, then the best place to check is the [maintainers
list](riscv-maintainers.html).  We tend to use [Git
Hub](https://github.com/riscv) to manage our ports (both in-tree and
out-of-tree), so if the maintainers list is out of date then you should check
there (and tell me the list is broken).

#### Is there a list of issues?

SiFive shoulders most of the burden of maintaining key RISC-V toolchain and
system software.  We generally track our bugs on a handful of GitHub
repositories.  Since things move quickly, the most up-to-date way to get
information about the projects is to just go on the bug trackers.

##### Build Scripts

[riscv-gnu-toolchain](https://github.com/riscv/riscv-gnu-toolchain/issues) is a
super-repo that contains build scripts for our Linux (binutils, GCC, and glibc)
and embedded (binutils, GCC, and newlib) toolchains.  While the repo itself
isn't all that interesting as it's just build scripts, but since it's the point
of contact for many people it tends to collect bugs in the issue tracker.

If you're looking to help out, I'd recommend using this repository to build
the tools and run regressions, but the bugs here tend to be less important.
I try to close any bugs in this repo and move them to the corresponding
project's repo once they've been looked at a bit, so the list here is a bit
more of a "bug triage" list not a "bug fix" list.

##### Binutils and GDB

[riscv-binutils-gdb](https://github.com/riscv/riscv-binutils-gdb/issues)
contains the source code for both binutils and GDB, which merged their upstream
repositories years ago.  Our binutils port is upstream but our GDB port is not
yet upstream, but both of the ports live in here.  In addition to the upstream
code you'll find a handful of work in progress patches that are rebased on top
of binutils regularly.

The ``riscv-next`` branch is based on binutils's master release and is
nominally a submission queue (though some WIP patches sit around for a while).
We also maintain backports to the latest upstream release on branches with
names like ``riscv-binutils-2.28``.  The backport branches are generally more
stable, but you should check both the queue and the [pull
requests](https://github.com/riscv/riscv-binutils-gdb/pulls) to make sure you
haven't duplicated work someone else is doing.  If you've come from an issue
then any pull request should be tagged in the issue, so you don't have to look
very hard.

##### GCC

[riscv-gcc](https://github.com/riscv/riscv-gcc/issues) contains the source code
for our GCC port, which has landed upstream.  The ``riscv-next`` branch is a
submission queue that's occasianally rebased, but we also maintain backports on
branches with names like ``riscv-gcc-7``.  In addition to the patches in the
submission queue, there are generally a handful of outstanding [pull
requests](https://github.com/riscv/riscv-gcc/pulls).

##### glibc

We maintain an out of tree port of
[Linux](https://github.com/riscv/riscv-linux/issues).  We're in the process of
submitting this port to upstream, so it's very much under flux.  If you're
really interested in contributing, it's probably best to subscribe to the
[patches](mailto:patches@groups.riscv.org) mailing list so you're always up to
date.  As the port is in progress, the ``riscv-next`` branch tends to be out of
date.  If you're looking for the latest and greatest (which may be unstable),
you're better off looking at the latest ``riscv-for-submission-vN`` branch.

##### Linux

We maintain an out of tree port of
[glibc](https://github.com/riscv/riscv-glibc/issues).  We're in the process of
submitting this port to upstream, so it's very much under flux.  If you're
really interested in contributing, it's probably best to subscribe to the
[patches](mailto:patches@groups.riscv.org) mailing list so you're always up to
date.  As the port is in progress, the ``riscv-next`` branch tends to be out of
date.  If you're looking for the latest and greatest (which may be unstable),
you're better off looking at the latest ``riscv-for-submission-vN`` branch.

### Toolchain-Related Questions (GCC, binutils, glibc, and newlib)

#### What is the difference between the -mabi and -march options?

We have decided to describe a RISC-V target using three bases:

* ``-march=ISA`` selects the architecture to target.  This controls which
  instructions and registers are available for the compiler to use.  We use
  lowercase RISC-V ISA strings to describe an architecture, as they've been
  standardized by the RISC-V ISA document (the lower case is a UNIX-ism, but
  one necessary to make some of the more esoteric tools work).  The ISA
  determines the set of architectures code can run on.
* ``-mabi=ABI`` selects the ABI to target.  This controls the calling
  convention (which arguments are passed in which registers) and the layout of
  data in memory.  One argument specifies both the integer and floating-point
  ABIs on RISC-V: we use the standard naming scheme for integer ABIs (``ilp32``
  or ``lp64``), with an optional single letter appended to select the
  floating-point registers used by the ABI (``ilp32`` vs ``ilp32f`` vs
  ``ilp32d``).  In order for objects to be linked together, they must follow
  the same ABI.
* ``-mtune=CODENAME`` selects the microarchitecture to target.  This informs
  GCC about the performance of each instruction, allowing it to perform
  target-specific optimizations.  This tuning should only effect performance,
  and as RISC-V is such a simple ISA it currently doesn't do much at all.

To get a bit more specific: Version 2.2 of the RISC-V User-Level ISA concretely
defines three base ISAs that are supported by the toolchain

* RV32I: A load-store ISA with 32, 32-bit general-purpose integer registers.
* RV32E: An embedded flavor of RV32I with only 16 integer registers.
* RV64I: A 64-bit flavor of RV32I where the general-purpose integer registers
  are 64-bits wide.

In addition to these base ISAs, a handful of extensions have been specified.
The extensions that have both been specified and are supported by the toolchain
are

* M: Integer Multiplication and Division
* A: Atomic Instructions
* F: Single-Precision Floating-Point
* D: Double-Precision Floating-Point
* C: Compressed Instructions

RISC-V ISA strings are defined by appending the supported extensions to the
base ISA in the order listed above.  For example, the RISC-V ISA with 32,
32-bit integer registers and the instructions to for multiplication would be
denoted as ``RV32IM``.  Users can control the set of instructions that GCC uses
when generating assembly code by passing the lower-case ISA string to the
``-march`` GCC option: for example ``-march=rv32im``.

On RISC-V systems that don't support particular operations, emulation routines
may be used to provide the missing functionality.  For example the following C code

  double dmul(double a, double b) {
    return a * b;
  }

will compile directly to a FP multiplication instruction when compiled with the
D extension

  $ riscv64-unknown-elf-gcc test.c -march=rv64gc -mabi=lp64d -o- -S -O3
  dmul:
    fmul.d  fa0,fa0,fa1
    ret

but will compile to an emulation routine without the D extension

  $ riscv64-unknown-elf-gcc test.c -march=rv64i -mabi=lp64 -o- -S -O3
  dmul:
          add     sp,sp,-16
          sd      ra,8(sp)
          call    __muldf3
          ld      ra,8(sp)
          add     sp,sp,16
          jr      ra

In addition to controlling the instructions available to GCC during code
generating (which defines the set of implementations the generated code will
run on), users can select from various ABIs to target (which defines the
calling convention and layout of objects in memory).  Objects and libraries may
only be linked together if they follow the same ABI.

RISC-V defines two integer ABIs and three floating-point ABIs, which together
are treated as a single ABI string.  The integer ABIs follow the standard ABI
naming scheme:

* ``ilp32``: ``int``, ``long``, and pointers are all 32-bits long.  ``long
  long`` is a 64-bit type, ``char`` is 8-bit, and ``short`` is 16-bit.
* ``lp64``: ``long`` and pointers are 64-bits long, while ``int`` is a 32-bit
  type.  The other types remain the same as ilp32.

while the floating-point ABIs are a RISC-V specific addition:

* "" (the empty string): No floating-point arguments are passed in registers.
* ``f``: 32-bit and smaller floating-point arguments are passed in registers.  This
  ABI requires the F extension, as without F there are no floating-point
  registers.
* ``d``: 64-bit and smaller floating-point arguments are passed in registers.  This
  ABI requires the D extension.

Just like ISA strings, ABI strings are concatenated together and passed via the
``-mabi`` argument to GCC.

* ``-march=rv32imafdc -mabi=ilp32d``: Hardware floating-point instructions can
  be generated and floating-point arguments are passed in registers.  This is
  like the ``-mfloat-abi=hard`` option to ARM's GCC.
* ``-march=rv32imac -mabi=ilp32``: No floating-point instructions can be
  generated and no floating-point arguments are passed in registers.  This is
  like the ``-mfloat-abi=soft`` argument to ARM's GCC.
* ``-march=rv32imafdc -mabi=ilp32``: Hardware floating-point instructions can
  be generated, but no floating-point arguments will be passed in registers.
  This is like the ``-mfloat-abi=softfp`` argument to ARM's GCC, and is usually
  used when interfacing with soft-float binaries on a hard-float system.
* ``-march=rv32imac -mabi=ilp32d``: Illegal, as the ABI requires floating-point
  arguments are passed in registers but the ISA defines no floating-point
  registers to pass them in.

As a more concrete example, let's examine how the following C program is
compiled for a host of ISA/ABI pairs:

  double dmul(double a, double b) {
    return a * b;
  }

  $ riscv64-unknown-elf-gcc test.c -march=rv32imac -mabi=ilp32 -o- -S -O3
  dmul:
    add     sp,sp,-16
    sw      ra,12(sp)
    call    __muldf3
    lw      ra,12(sp)
    add     sp,sp,16
    jr      ra

  $ riscv64-unknown-elf-gcc test.c -march=rv32imafdc -mabi=ilp32 -o- -S -O3
  dmul:
    add     sp,sp,-16
    sw      a0,8(sp)
    sw      a1,12(sp)
    fld     fa5,8(sp)
    sw      a2,8(sp)
    sw      a3,12(sp)
    fld     fa4,8(sp)
    fmul.d  fa5,fa5,fa4
    fsd     fa5,8(sp)
    lw      a0,8(sp)
    lw      a1,12(sp)
    add     sp,sp,16
    jr      ra

  $ riscv64-unknown-elf-gcc test.c -march=rv32imafdc -mabi=ilp32d -o- -S -O3
  dmul:
    fmul.d  fa0,fa0,fa1
    ret

  $ riscv64-unknown-elf-gcc test.c -march=rv32imac -mabi=ilp32d -o- -S -O3
  cc1: error: requested ABI requires -march to subsume the 'D' extension

The ``-mtune`` option is the least interesting of the bunch.  RISC-V is such a
simple ISA that it doesn't suffer from the decode problems that an ISA like ARM
or ia32 does, and the extant implementations are simple enough that it doesn't
suffer from odd instruction parings like the Pentium does, so there really
isn't much to control here.  Unless you're going to contribute a new tuning
model to GCC, you probably shouldn't bother setting this option.

#### Where is the 32-bit toolchain?

The RISC-V ports of binutils and GCC support all ISA variants using a single
binary, regardless of whether the binary is called ``riscv32-unknown-elf-gcc``
or ``riscv64-unknown-elf-gcc``.  Additionally, we usually produce multilib
toolchains so multiple copies of the C libraries are installed along with the
toolchain.  You can probably build code for your architecture by running

 ``riscv{32,64}-unknown-elf-gcc -march=ISA -mabi=ABI`` ...

where ISA and ABI are the ones you're interested in.  As there are many RISC-V
ISA and ABI variants, we only build C libraries for a handful of common
targets.  If your toolchain can't find a C library for your ISA/ABI pair, then
you can

* Pick a different (but similar) ISA.  As a hint, we really like the C
  extension so if you're not using it then you probably want to.
* Petition us to add a reuse pattern for your ISA/ABI pair, which will cause
  GCC to use a different C library (which a compatible ABI) when linking your
  code -- the code you actually build will be built with the ISA you specify.
  We have a handful of these for ISA/ABI pairs we felt were similar enough to
  each other, but we're amenable to adding more.
* Petition us to add support for your ISA/ABI pair to the default set of
  multilibs.  We picked the original set guessing as to what hardware would be
  popular, but if we're wrong we're amenable to adding more popular pairs.

While we agree it's a bit odd to have both the ``riscv32-*`` and ``riscv64-*``
tuples when there's functionally little difference (just the default ISA and
ABI targets), there wasn't really a good option when specifying these.  There
are three styles of architecture tuples for ISAs that have both 32-bit and
64-bit tuples:

* ``arm-*/aarch64-*``, ``tilepro-*/tilegx-*``: These ports are entirely
  separate: for example the ``arm-*`` toolchain only supports ARMv7, and the
  ``aarch64-*`` toolchain only support ARMv8/aarch64.
* ``hppa-*/hppa64-*``, ``mips-*/mips3-*/mips64-*``, ``rs6000-* /
  powerpc-*/powerpc64-*``, ``sparc-*/sparcv8-*/sparcv9-*/sparc64-*``,
  ``sh-*/sh2-*/sh3-*/sh4-*/sh64-*``: These ports have two compiler tuples.  The
  newer tuple contains "64", and can target both their 32-bit and 64-bit ISAs.
  The older tuple contains no suffix and can only target the 32-bit ISA.  For
  the targets with multiple tuples, those other tuples just behave as aliases
  (aside from maybe a default ISA target difference).
* ``i386-*/i486-*/i586-*/i686-*/x86_64-*``: These ports avoid the ambiguity
  when referring to the 32-bit version, but otherwise act like above.

On RISC-V, we originally had our tuples called ``riscv-*`` and ``riscv32-*``.
This was confusing, as the non-suffixed version's polarity was different than
all the other architectures.  In order to avoid this confusion, we decided to
follow the naming scheme that Intel uses, and that it appears that ARM would
use if they ever bother with an aarch32 port (which I assume they won't).  If
we'd left it the other way, we'd still have the same FAQ text here, the title
would just be "where is the 64-bit toolchain?" :).

There's two things were doing that aren't standard:

* We didn't bother with an ambiguous tuple alias, as it was suggested we
  shouldn't have one.  I think if people though there was going to be a mips64
  they would have called it mips32 instead of just mips -- they did this when
  renaming the ISA, but it's very hard to rename ambiguous things in
  software-land so they'll be stuck with that forever.
* Our 32-bit toolchain can generate 64-bit ELFs.

Note that it's not feasible to have a single target, as some platforms do not
support 64-bit BFDs and therefor there needs to be some 32-bit-only tuple.

#### What is a code model?

Most programs do not fill the entire address space available to them with
symbols (most don't fill it at all, but those that do tend to fill their
address space with heap).  ISAs tend to take advantage of this locality by
implementing shorter addressing modes in hardware and relying on software to
provide larger address modes.  The code model determines which software
addressing mode is used, and therefor what constraints are enforced on the
linked program.

Code models are necessary due to the split between the compiler and the linker:
when generating an un-linked object the complier doesn't know the absolute
address of any symbol but it still must know what addressing mode to use as
some addressing modes may require scratch registers to operate.  As the
compiler cannot generate actual addressing code, it generates addressing
templates (known as relocations) that the linker can then fix up once it knows
the actual addresses of each symbol.

This is probably best explained with an example.  Imagine the following C code:

  long global_symbol[2];

  int main() {
    return global_symbol[0] != 0;
  }

Even though a single GCC invocation can produce a binary for this simple case,
under the covers the GCC driver script is actually running the preprocessor,
then the compiler, then the assembler, and finally the linker.  The
``--save-temps`` argument to GCC allows users to see all these intermediate
files, and is a useful argument for poking around inside the toolchain.

  $ riscv64-unknown-linux-gnu-gcc cmodel.c -o cmodel -O3 --save-temps

Each step in this run of the GCC wrapper script generates a file:

* ``cmodel.i``: The preprocessed source, which expands any preprocessor
  directives (things like ``#include`` or ``#ifdef``).
* ``cmodel.s``: The output of the actual compiler, which is an assembly file (a
  text file in the RISC-V assembly format).
* ``cmodel.o``: The output of the assembler, which is an un-linked object file
  (an ELF file, but not an executable ELF).
* ``cmodel``: The output of the linker, which is a linked executable (an
  executable ELF file).

In order to understand why the code model exists, we must first examine this
toolchain flow in a bit more detail.  Since this is a simple source file with
no preprocessor macros, the preprocessor run is pretty boring: all it does is
emit some directives to be used if debugging information is later generated:

  $ cat cmodel.i
  # 1 "cmodel.c"
  # 1 "built-in"
  # 1 "command-line"
  # 31 "command-line"
  # 1 "/scratch/palmer/work/upstream/riscv-gnu-toolchain/build/install/sysroot/usr/include/stdc-predef.h" 1 3 4
  # 32 "command-line" 2
  # 1 "cmodel.c"
  long global_symbol;
  
  int main() {
    return global_symbol != 0;
  }

The preprocessed output is then fed through the compiler, which generates a
assembly file.  This file is plain-text that contains RISC-V assembly code, and
therefor is easy to read:

  $ cat cmodel.s
  main:
    lui   a5,%hi(global_symbol)
    ld    a0,%lo(global_symbol)(a5)
    snez  a0,a0
    ret

The generated assembly contains a pair of instructions to address
``global_symbol``: ``lui`` and then ``ld``.  This imposes a constraint on the
address that ``global_symbol`` can take on: it must be addressable by a 32-bit
signed absolute constant (not 32-bit offset from some register or the PC, but
actually a 32-bit address).  Note that the restriction on symbol addresses is
not related to the size of a pointer on this architecture: specifically points
may still be 64-bits here, but all global symbols must be addressable by a
32-bit absolute address.

After the compiler generates assembly, the GCC wrapper script calls the
assembler to generate an object file.  This file is an ELF binary, which can be
read with a variety of tools provided by Binutils.  In case we'll use
``objdump`` to show the symbol table, disassemble the text section, and show
the relocations generated by the assembler:

  $ riscv64-unknown-linux-gnu-objdump -d -t -r cmodel.o

  cmodel.o:     file format elf64-littleriscv
  
  SYMBOL TABLE:
  0000000000000000 l    df *ABS*  0000000000000000 cmodel.c
  0000000000000000 l    d  .text  0000000000000000 .text
  0000000000000000 l    d  .data  0000000000000000 .data
  0000000000000000 l    d  .bss   0000000000000000 .bss
  0000000000000000 l    d  .text.startup  0000000000000000 .text.startup
  0000000000000000 l    d  .comment       0000000000000000 .comment
  0000000000000000 g     F .text.startup  000000000000000e main
  0000000000000010       O *COM*  0000000000000008 global_symbol
  
  Disassembly of section .text.startup:
  
  0000000000000000 main:
     0:   000007b7                lui     a5,0x0
                          0: R_RISCV_HI20 global_symbol
                          0: R_RISCV_RELAX        *ABS*
     4:   0007b503                ld      a0,0(a5) # 0 main
                          4: R_RISCV_LO12_I       global_symbol
                          4: R_RISCV_RELAX        *ABS*
     8:   00a03533                snez    a0,a0
     c:   8082                    ret

At this point we have an object file, but we still don't know the actual
addresses of any global symbols.  This is where there's a bit of overlap in the
roles of each component of the toolchain: it's the assembler's job to convert
textual instructions into bits, but in the cases where those bits depend on the
address of a global symbol (like the ``lui`` in the code above, for example)
the assembler can't know what those bits should actually be.  In order to allow
the linker to fill out these bits in the final executable object file, the
assembler generates entries in a relocation table for every bit range the
linker is expected to fill out.  Relocations define a bit range that the linker
is meant to fill out when linking the code together.  The specific definition
of any relocation type present in the text section is ISA-specific, the RISC-V
definitions can be found in our [ELF psABI
document](https://github.com/riscv/riscv-elf-psabi-doc/blob/master/riscv-elf.md).

After assembling the program, the GCC wrapper script runs the linker to
generate an executable.  This is another ELF file, but this time it's a full
executable.  Since this contains lots of C library code, I'm going to show only
the relevant fragments of it here:

  $ riscv64-unknown-linux-gnu-objdump -d -t -r cmodel
  cmodel:     file format elf64-littleriscv
  
  SYMBOL TABLE:
  0000000000012038 g     O .bss	0000000000000010              global_symbol
  ...
  
  Disassembly of section .text:
  
  0000000000010330 main:
   10330:       67c9                    lui     a5,0x12
   10332:       0387b503                ld      a0,56(a5) # 12038 global_symbol
   10336:       00a03533                snez    a0,a0
   1033a:       8082                    ret

There are a few interesting things to note here:

* The symbol table contains symbols with actual, absolute values.  This is the
  whole point of the linker.
* The text section contains the correct bits to actually reference the global
  symbols, as opposed to just a bunch of 0's.
* The relocations against global symbols have been removed, as they're no
  longer necessary.  Some relocations may still exist in executables to allow
  for things like dynamic linking, but in this simple case there are none.

Up until now, this example has been using RISC-V's default code model
[medlow](#what-does--mcmodel-medlow-mean-).  In order to demonstrate a bit more
specifically what a code model is

#### What does -mcmodel=medlow mean?

This selects the medium-low [code model](#what-is-a-code-model-), which means
program and its statically defined symbols must lie within a single 2 GiB
address range and must lie between absolute addresses -2 GiB and +2 GiB.
Addressing for global symbols uses ``lui``/``addi`` instruction pairs, which
emit the ``R_RISCV_HI20``/``R_RISCV_LO12_I`` sequences.  Here's an example of
some generated code using the medlow code model:

  $ cat cmodel.c 
  long global_symbol[2];
  
  int main() {
    return global_symbol[0] != 0;
  }

  $ riscv64-unknown-linux-gnu-gcc cmodel.c -o cmodel -O3 --save-temps -mcmodel=medlow

  $ cat cmodel.s
  main:
          lui     a5,%hi(global_symbol)
          ld      a0,%lo(global_symbol)(a5)
          snez    a0,a0
          ret
  
  $ riscv64-unknown-linux-gnu-objdump -d -r cmodel.o
  cmodel.o:     file format elf64-littleriscv
  
  Disassembly of section .text.startup:
  
  0000000000000000 main:
     0:   000007b7                lui     a5,0x0
                          0: R_RISCV_HI20 global_symbol
                          0: R_RISCV_RELAX        *ABS*
     4:   0007b503                ld      a0,0(a5) # 0 main
                          4: R_RISCV_LO12_I       global_symbol
                          4: R_RISCV_RELAX        *ABS*
     8:   00a03533                snez    a0,a0
     c:   8082                    ret
  
  $ riscv64-unknown-linux-gnu-objdump -d -r cmodel
  Disassembly of section .text:
  
  0000000000010330 main:
     10330:       67c9                    lui     a5,0x12
     10332:       0387b503                ld      a0,56(a5) # 12038 global_symbol
     10336:       00a03533                snez    a0,a0
     1033a:       8082                    ret

#### What does -mcmodel=medany mean?

This selects the medium-low [code model](#what-is-a-code-model-), which means
program and its statically defined symbols must lie within any single 2 GiB
address range.  Addressing for global symbols uses ``lui``/``addi`` instruction
pairs, which emit the ``R_RISCV_PCREL_HI20``/``R_RISCV_PCREL_LO12_I``
sequences.  Here's an example of some generated code using the medlow code
model (with [-mexplicit-relocs](#what-does--m-explicit-relocs-mean-), in order
to make this match the [-mcmodel=medlow](#what-does--mcmodel-medlow-mean-)
example a bit more cleanly):

  $ cat cmodel.c
  long global_symbol[2];
  
  int main() {
    return global_symbol[0] != 0;
  }
  
  $ riscv64-unknown-linux-gnu-gcc cmodel.c -o cmodel -O3 --save-temps -mcmodel=medany -mexplicit-relocs
  
  $ cat cmodel.s
  main:
          .LA0: auipc     a5,%pcrel_hi(global_symbol)
          ld      a0,%pcrel_lo(.LA0)(a5)
          snez    a0,a0
          ret
  
  $ riscv64-unknown-linux-gnu-objdump -d -r cmodel.o
  cmodel.o:     file format elf64-littleriscv
  
  SYMBOL TABLE:
  0000000000000000 l    df *ABS*  0000000000000000 cmodel.c
  0000000000000000 l    d  .text  0000000000000000 .text
  0000000000000000 l    d  .data  0000000000000000 .data
  0000000000000000 l    d  .bss   0000000000000000 .bss
  0000000000000000 l    d  .text.startup  0000000000000000 .text.startup
  0000000000000000 l       .text.startup  0000000000000000 .LA0
  0000000000000000 l    d  .comment       0000000000000000 .comment
  0000000000000000 g     F .text.startup  000000000000000e main
  0000000000000010       O *COM*  0000000000000008 global_symbol
  
  Disassembly of section .text.startup:
  
  0000000000000000 main:
     0:   00000797                auipc   a5,0x0
                          0: R_RISCV_PCREL_HI20   global_symbol
                          0: R_RISCV_RELAX        *ABS*
     4:   0007b503                ld      a0,0(a5) # 0 main
                          4: R_RISCV_PCREL_LO12_I .LA0
                          4: R_RISCV_RELAX        *ABS*
     8:   00a03533                snez    a0,a0
     c:   8082                    ret
  
  $ riscv64-unknown-linux-gnu-objdump -d -r cmodel.o
  Disassembly of section .text:
  
  0000000000010330 main:
     10330:       00002797                auipc   a5,0x2
     10334:       d087b503                ld      a0,-760(a5) # 12038 global_symbol
     10338:       00a03533                snez    a0,a0
     1033c:       8082                    ret
          ...

Note that that ``-mcmodel=medany`` currently defaults to
[-mno-explicit-relocs](#what-does--m-explicit-relocs-mean-), which can have an
appreciable performance effect.

#### What is linker relaxation?

Linker relaxation is a form of optimization that occurs when linking a program
rather than when compiling when a program, which is where most optimization
happens.  While all ISAs are capable of performing linker relaxations, the
RISC-V ISA was explicitly designed with them in mind.  Specifically, in order
to avoid the plethora of hardware addressing modes that most ISAs are full of,
RISC-V instead provides a small number of hardware addressing modes and relies
on software to use them efficiently.  As addressing modes cost a lot of ISA
space, this innovation is one of the important design constraints that allows
RISC-V to be as it is.

The one drawback to aggressively implementing linker relaxations is that users
who care about the performance of their code need to not only understand what
the compiler does, but additionally need to understand what the linker does.
The easiest way to poke around linker relaxations is to look at how some simple
programs are relaxed.  Here's an example program that demonstrates both data
and text relocations:

  long near;
  long near[1  12];
  long far;
  
  long data(void) {
    return near | far;
  }
  
  int main() {
    return data();
  }

Even though a single GCC invocation can produce a binary for this simple case,
under the covers the GCC driver script is actually running the preprocessor,
then the compiler, then the assembler, and finally the linker.  The
``--save-temps`` argument to GCC allows users to see all these intermediate
files, and is a useful argument for poking around inside the toolchain.

  $ riscv64-unknown-linux-gnu-gcc relax.c -o relax -O3 --save-temps

Each step in this run of the GCC wrapper script generates a file:

* ``relax.i``: The preprocessed source, which expands any preprocessor
  directives (things like ``#include`` or ``#ifdef``).
* ``relax.s``: The output of the actual compiler, which is an assembly file (a
  text file in the RISC-V assembly format).
* ``relax.o``: The output of the assembler, which is an un-linked object file
  (an ELF file, but not an executable ELF).
* ``relax``: The output of the linker, which is a linked executable (an
  executable ELF file).

Since this is a simple source file with no preprocessor macros, the
preprocessor run is pretty boring: all it does is emit some directives to be
used if debugging information is later generated:

  # 1 "relax.c"
  # 1 "built-in"
  # 1 "command-line"
  # 31 "command-line"
  # 1 "/scratch/palmer/work/upstream/riscv-gnu-toolchain/build/install/sysroot/usr/include/stdc-predef.h" 1 3 4
  # 32 "command-line" 2
  # 1 "relax.c"
  long near;
  long far[2];
  
  long data(void) {
    return near | far;
  }
  
  int main() {
    return data();
  }

The preprocessed output is then fed through the compiler, which generates a
assembly file. This file is plain-text that contains RISC-V assembly code, and
therefor is easy to read:

  $ cat relax.s
  data:
          lui     a5,%hi(near)
          ld      a0,%lo(near)(a5)
          lui     a5,%hi(far)
          ld      a5,%lo(far)(a5)
          or      a0,a0,a5
          ret
  
  main:
          add     sp,sp,-16
          sd      ra,8(sp)
          call    data
          ld      ra,8(sp)
          sext.w  a0,a0
          add     sp,sp,16
          jr      ra

As you can see, this isn't the RISC-V assembly that you would see in the
instruction manual:

* There are additional assembler directives that allow operands to refer to
  part of a symbol's value.  For example, see the ``%low`` directive in
  ``data``, which refers to the low 12 bits of a symbol's address.
* There are additional assembler pseudo-ops that stand for multi-instruction
  sequences.  For example, see the ``call`` pseudo-op which just both a ``jal``
  instruction and some 

While assembling the program into an object file (an ELF that is not an
executable), the assembler will turn these special directives and pseudo-ops
into relocations:

  relax.o:     file format elf64-littleriscv
  
  Disassembly of section .text:
  
  0000000000000000 data:
     0:   000007b7                lui     a5,0x0
                          0: R_RISCV_HI20 near
                          0: R_RISCV_RELAX        *ABS*
     4:   0007b503                ld      a0,0(a5) # 0 data
                          4: R_RISCV_LO12_I       near
                          4: R_RISCV_RELAX        *ABS*
     8:   000007b7                lui     a5,0x0
                          8: R_RISCV_HI20 far
                          8: R_RISCV_RELAX        *ABS*
     c:   0007b783                ld      a5,0(a5) # 0 data
                          c: R_RISCV_LO12_I       far
                          c: R_RISCV_RELAX        *ABS*
    10:   8d5d                    or      a0,a0,a5
    12:   8082                    ret
  
  Disassembly of section .text.startup:
  
  0000000000000000 main:
     0:   1141                    addi    sp,sp,-16
     2:   e406                    sd      ra,8(sp)
     4:   00000097                auipc   ra,0x0
                          4: R_RISCV_CALL data
                          4: R_RISCV_RELAX        *ABS*
     8:   000080e7                jalr    ra
     c:   60a2                    ld      ra,8(sp)
     e:   2501                    sext.w  a0,a0
    10:   0141                    addi    sp,sp,16
    12:   8082                    ret

At this point we have an object file, but we still don't know the actual
addresses of any global symbols. This is where there's a bit of overlap in the
roles of each component of the toolchain: it's the assembler's job to convert
textual instructions into bits, but in the cases where those bits depend on the
address of a global symbol (like the lui in the code above, for example) the
assembler can't know what those bits should actually be. In order to allow the
linker to fill out these bits in the final executable object file, the
assembler generates entries in a relocation table for every bit range the
linker is expected to fill out. Relocations define a bit range that the linker
is meant to fill out when linking the code together. The specific definition of
any relocation type present in the text section is ISA-specific, the RISC-V
definitions can be found in our ELF psABI document.

We've now reached the point at which we can examine a linker relaxation: the
final link.  Since it's generally better to perform optimization in the
compiler as opposed to the linker, we try to optimize as much as possible when
compiling.  The only optimizations deferred to the linker are those that
require knowledge of the actual value of symbol addresses.  It's probably
easier to explain this with an example, so let's first start with the fully
linked and optimized executable:

  $ riscv64-unknown-linux-gnu-objdump -d -r relax
  Disassembly of section .text:
  
  0000000000010330 main:
     10330:       1141                    addi    sp,sp,-16
     10332:       e406                    sd      ra,8(sp)
     10334:       0b8000ef                jal     ra,103ec data
     10338:       60a2                    ld      ra,8(sp)
     1033a:       2501                    sext.w  a0,a0
     1033c:       0141                    addi    sp,sp,16
     1033e:       8082                    ret
  
  00000000000103ec data:
     103ec:       8181b503                ld      a0,-2024(gp) # 12038 near
     103f0:       67e9                    lui     a5,0x1a
     103f2:       0407b783                ld      a5,64(a5) # 1a040 far
     103f6:       8d5d                    or      a0,a0,a5
     103f8:       8082                    ret

If you compare the linked executable to the unlinked object file, you'll notice
a handful of differences:

* The symbol table contains symbols with actual, absolute values. This is the
  whole point of the linker.
* The text section contains the correct bits to actually reference the global
  symbols, as opposed to just a bunch of 0's.
* The relocations against global symbols have been removed, as they're no
  longer necessary. Some relocations may still exist in executables to allow
  for things like dynamic linking, but in this simple case there are none.
* There are fewer instructions in the executable than the object file.

The first three points are just the result of performing relocations, but the
last bullet is the result of performing a relaxation.  Specifically: resolving
relocations doesn't change the instruction count, while performing relaxations
reduces the number of instructions.  In this example there were three sets of
relocations, two of which were relaxable and one which was not.  Let's look at
them to see exactly what happened:

  --- relax.o
  +++ relax
  -      4:   00000097                auipc   ra,0x0
  -                           4: R_RISCV_CALL         data
  -                           4: R_RISCV_RELAX        *ABS*
  -      8:   000080e7                jalr    ra
  +  10334:   0b8000ef                jal     ra,103ec data

In the example above, we can see the ``R_RISCV_CALL`` relocation is requested.
This relocation is defined to operate over an adjacent ``auipc``/``jalr`` pair,
referencing a signed 32-bit PC-relative call target.  In this case we were able
to relax this instruction pair to a single ``jal`` instruction as the actual
call target was within a 21-bit signed offset from the current PC.  You'll find
that almost all ``R_RISCV_CALL`` relocations will be relaxable, as most code
expresses some amount of call locality.

  --- relax.o
  +++ relax
  -      0:   000007b7                lui     a5,0x0
  -                          0: R_RISCV_HI20         near
  -                          0: R_RISCV_RELAX        *ABS*
  -      4:   0007b503                ld      a0,0(a5) # 0 data
  -                          4: R_RISCV_LO12_I       near
  -                          4: R_RISCV_RELAX        *ABS*
  +  103ec:   8181b503                ld      a0,-2024(gp) # 12038 near

In the example above, we can see a ``R_RISCV_HI20``/``R_RISCV_LO12_I``
relocation pair is requested.  These relocations are each defined to operate
over a single instruction: the ``R_RISCV_HI20`` relocates the 20-bit offset of
a ``lui`` while the ``R_RISCV_LO12_I`` relocates the 12-bit offset of various
I-type instructions (``ld`` in this example).  In this case we were able to
relax this instruction pair to a single ``ld`` instruction, as the final symbol
address was within a 12-bit offset of ``gp``, the global pointer.

  --- relax.o
  +++ relax
  -      8:   000007b7                lui     a5,0x0
  -                           8: R_RISCV_HI20         far
  -                           8: R_RISCV_RELAX        *ABS*
  -      c:   0007b783                ld      a5,0(a5) # 0 data
  -                           c: R_RISCV_LO12_I       far
  -                           c: R_RISCV_RELAX        *ABS*
  +  103f0:   67e9                    lui     a5,0x1a
  +  103f2:   0407b783                ld      a5,64(a5) # 1a040 far

In the example above we see another ``R_RISCV_HI20``/``R_RISCV_LO12_I``, but
this time we can't relax it as it's not within a 12-bit offset of ``gp``.  Note
that we still generate the correct code for this case by filling out the
relocations.  You will get a link-time error whenever it is impossible to
correctly relocate a requested relocation, as otherwise the linked executable
wouldn't produce the correct answer.
